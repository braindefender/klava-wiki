# Why so sticky? / Чего такой липкий?

> Что такое OSSM модификаторы и почему я использую именно их?

Для начала, речь пойдёт про про [сплиты](/dictionary.md#сплит) и [модификаторы](/dictionary.md#модификатор) (Shift, Ctrl, Alt и Gui),
расположенные на Home-Row — [Home-Row Mods](/dictionary.md#home-row-mods), или коротко — `HRM`.

Реализовать такие модификаторы можно разными способами.

## Простые модификаторы в слое

Начнём с простого. В базовом слое у нас расположены буквы.
Но мы хотим иметь доступ к модификаторам на тех же местах,
на которых расположены `ASDF` и `JKL;`.

Логичным, будет поместить модификаторы в слой на эти места.

Тогда наш keymap будет выглядеть примерно так:

```toml
[layer.base]
"""
  Q    W    E     R      T        |        Y        U        I        O        P
  A    S    D     F      G        |        H        J        K        L        ;
  Z    X    C     V      B        |        N        M        ,        .        /
            _     _      MO(raise)|        _        _        _
"""

[layer.raise]
"""
  _    _    _     _        _        |        _   _      _     _    _
  LGui LAlt LCtrl LShift   _        |        _   RShift RCtrl RAlt RGui
  _    _    _     _        _        |        _   _      _     _    _
"""
```

Какие проблемы с этим есть уже сейчас?

### 1. Правые и левые модификаторы

В слое с модификаторами есть левые и правые модификаторы (LAlt и RAlt).<br>
Звучит логично ведь? Левые слева, правые — справа.

Однако, `RAlt` в большинстве систем, это не просто `RAlt`, а так называемый `AltGr`.
Фактически, это `Ctrl+Alt` — так устроены клавиатуры и их обработка в системе.
Нам хотелось бы, чтобы эти модификаторы были однозначными, что слева, что справа.

**Решение:** `RAlt` мы использовать не будем и напишем вместо него `LAlt`.
Тоже самое сделаем и для других модификаторов, т.к. по сути, разницы в них никакой нет.

### 2. Как их прожимать? Удерживать?

У нас всего один слой с модификаторами. И чтобы, скажем, нажать `Ctrl+Shift+T`, нам нужно:
- зажать большим пальцем левой руки `MO(raise)`
- зажать `RShift` и `RCtrl` указательным и средним пальцами правой руки
- отпустить большой палец левой руки
- тапнуть `T`

Нам обязательно пришлось использовать правую руку и зажимать модификаторы.
Иначе, пришлось бы изголяться, удерживая средний и указательный пальцы левой руки,
чтобы нажать `T`.

И так придётся делать для всех комбинаций клавиш. Звучит не слишком удобно.

### 3. Нужны обязательно две руки

Например, нам нужно нажать `Ctrl+D`. Нам придётся использовать правую руку,
ибо `D` находится на месте модификатора `LCtrl`, а он уже будет зажат.

**Вывод:** одной рукой такие сочетания с простыми модификаторами в слое не нажать.

А какие у них плюсы? Они работают как обычные клавиши.
То есть, если вам нужно вызвать меню Пуск в Windows,
то вы просто нажимаете `LGui` два раза.

## Home-Row Mods

Это, пожалуй, классический способ реализации HRM (он даже называется идентично).
Мы делаем клавиши `A S D F` не простыми клавишами, а Mod-Tap клавишами.

`MT(LCtrl, D)` будет печатать букву `D` при тапе, а при зажатии будет работать как `LCtrl`.

Получаем вот такой keymap:

```toml
[layer.base]
"""
  Q           W           E            R               T        |        Y   U             I            O           P
  MT(LGui, A) MT(LAlt, S) MT(LCtrl, D) MT(LShift, F)   G        |        H   MT(LShift, J) MT(LCtrl, K) MT(LAlt, D) MT(LGui, ;)
  Z           X           C            V               B        |        N   M             ,            .           /
                          _            _               _        |        _   _             _
"""
```

Так мы вообще не привязаны к слоям, ибо модификаторы лежат прямо в базовом слое.

Какие проблемы есть тут?

1. `Ctrl+D` нажать одной рукой снова не получится, потому что `MT(LCtrl, D)` использует ту же клавишу!
2. Настройка таймингов зажатия по-умолчанию может вам не подойти и у вас будут ложные срабатывания модификаторов.
3. Эти тайминги зажатия придётся ловить, либо вырабатывать определённый темп печати / работы за клавиатурой.

> Я вот совершенно не люблю ловить тайминги и мой темп печати может сильно варьироваться в течение дня.
> Поэтому HRM в классической реализации мне не подходит.
>
> <br>
>
> К тому же, я не всегда держу руки на клавиатуре.
> В программах вроде CAD'ов, Photoshop, Figma и других визуальных редакторах, правая рука лежит на мышке.
>
> <br>
>
> И я попросту не смогу нажать часть сочетаний с модификаторами одной лишь левой рукой. Как это решить?

## One-Shot Modifiers

Или `OSM`, если кратко. Суть `OSM` проста — такой модификатор, при нажатии, запоминается в клавиатуре,
и если после этого будет нажата другая клавиша не-модификатор, то нажмётся полный шорт-кат,
а модификатор, после нажатия этой клавиши, перестанет действовать.

То есть, можно спокойно нажимать такие модификаторы одной лишь левой рукой:
```
1. Press::MO(raise)
2. Tap::OSM(LCtrl)
3. Release::MO(raise)
4. Tap::D

= LCtrl+D
```

Также, при нажатии `OSM` создаётся таймер, и если вы ничего не будете нажимать, пока он не пройдёт,
то модификатор просто отменится. Наверное, это защита от случайных нажатий.

Можно выставить таймер сброса `OSM` в какое-то очень большое число.<br>
Тогда, если нажать такой модификатор, он залипнет надолго.

Таким образом, `OSM` позволяет нам вообще не париться о таймингах, в отличие от `HRM`.
Случайных нажатий при обычной печати не произойдёт, потому что `OSM` находятся в слое.

Также, `OSM` можно комбинировать с другими `OSM` — они просто запомнятся в памяти,
а при нажатии другой клавиши все запомненные модификаторы просуммируются.

Правда, из-за этого не получится открыть меню Пуск в Windows по `OSM(LGui)`,
потому что `OSM` лишь добавится в очередь, а не фактически нажмётся.

## One-Shot Sticky Modifiers

Можно настроить `OSM` так, чтобы при нажатии, он приводил модификатор в состояние зажатия.
Это называется One-Shot Sticky Modifier или `OSSM`.

> или non-lazy OSM режим в ZMK

В чём плюсы `OSSM`? Какие у этого применения?

Например, если в Telegram зажать такой `OSM(LCtrl)`,
то можно скроллить длинные чаты постранично,
вообще отпустив руки с клавиатуры.

Или вот в CAD-системах, можно зажать тот же `OSM(LCtrl)`
и вертеть модельку мышкой, опять же, отпустив руки с клавиш.

Да и в целом, `OSSM` не заставляет нас что-то удерживать, он начинает работать сразу после нажатия.
Однако, с обычными `OSSM` есть проблема — их нельзя отменить, не нажав какую-либо другую клавишу.
Либо, нужно ждать, пока пройдёт таймер сброса, а он может быть очень большим.

Поэтому, в моей прошивке [Wellum](/layouts/combined/wellum.md) реализован функционал
принудительного отжатия `OSSM` с помощью клавиш слоя (`NAV` и `SYM`).

Если модификатор был зажат, а потом стал не нужен, то я просто отжимаю его,
без необходимости нажимать какую-либо другую клавишу или ждать таймер.

Также, в Wellum имеется возможность нажать `OSSM` модификаторы дважды,
для того, чтобы они сработали как обычное нажатие клавиши.
Это позволяет открывать меню Пуск при повторном нажатии `OSSM(LGui)`.

## В заключение

У всех реализаций Home-Row Mods есть как свои плюсы, так и минусы.

Для меня, `OSSM` — это наилучший компромисс между удобством и функциональностью.

Он позволяет мне не ловить тайминги, которые я так не люблю,
даёт мне возможность набирать сочетания клавиш одной лишь левой рукой,
но принуждает меня нажимать дополнительные клавиши для отмены модификаторов.

Да, чтобы довести до ума стандартную реализацию `OSSM`, придётся написать довольно много кода.
Иногда это того стоит. Если и вам идея ловить тайминги не близка, то рекомендую попробовать `OSSM`.
